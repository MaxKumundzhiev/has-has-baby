## Heap
Куча - реализуется через структуру данных дерево (`не путать со свойствами бинарного дерева поиска`)

Куча может применяться в следующих задачах:
1. найти K (наибольших | наименьших) элементов
2. найти K-ый (наибольшый | наименьший) элемент


Свойства кучи:
- каждый ребенок - это и есть куча, то есть свойства будут распространяться на каждое поддерево
- для текущего элемента работает правило: 
    - `все что внизу - оно меньше` (для макс кучи)
    - `все что внизу - оно больше` (для мин кучи)
- куча гарантирует:
    - `в самом верху самый наибольший элемент` (для макс кучи)
    - `в самом верху самый наименьший элемент` (для мин кучи)


Основные операции кучи:
- положить в кучу X
- достать самый большой | маленький элемент
- удалить самый большой | маленький элемент
- heapify - это процедура, которая позволяет из массива сделать куча на максимум или на минимум
- дополнительно:
    - shiftUp
    - shiftDown


## Реализация
Кучу обычно реализуют на динамическом массиве.

- shiftUp (просеять наверх) (time O(log(n)))
```text
помним, что у нас есть динамический массив, где мы храним все элменты кучи.
просеять вверх - это означает довести элемент вверх, чтобы выполнялись все свойства кучи.

как работает
1. находим индекс родителя:
    parentIdx = (idx-1) // 2
2. заходим в родителя и проверяем, если:
    parentValue = array[parentIdx]
    для max heap:
        if currentValue > parentValue:
            array[idx], array[parentIdx] = parentValue, currentValue
    для min heap:
        if currentValue < parentValue:
            array[idx], array[parentIdx] = parentValue, currentValue
3. передвигаемся на родителя и запускаем такую же процедуру
```

- shiftDown (просеять вниз) (time O(log(n)))
```text
помним, что у нас есть динамический массив, где мы храним все элменты кучи.
просеять вниз - это означает довести элемент вниз, чтобы выполнялись все свойства кучи.

как работает
1. находим индексы левого и правого детей:
    leftIdx = idx*2-1
    rightIdx = idx*2-2
2. заходим в детей и проверяем, если:
    leftValue = array[leftIdx]
    rightValue = array[rightIdx]
    
    # просеиваим вниз в сторону максимального элемента
    # ищем МАКСИМАЛЬНЫЙ элемент между детьми и просеиваем в сторону максимально
    для max heap:
        maxValue = max(leftValue, rightValue)
        # двигаемся влево
        if maxValue == leftValue:
            array[idx], array[leftIdx] = leftValue, currentValue
        # двигаемся вправо
        else:
            array[idx], array[rightIdx] = rightValue, currentValue

    # просеиваим вниз в сторону минимального элемента
    # ищем МИНИМАЛЬНЫЙ элемент между детьми и просеиваем в сторону минимального
    для min heap:
        minValue = min(leftValue, rightValue)
        # двигаемся влево
        if minValue == leftValue:
            array[idx], array[leftIdx] = leftValue, currentValue
        # двигаемся вправо
        else:
            array[idx], array[rightIdx] = rightValue, currentValue
3. передвигаемся на min | max ребенка и запускаем такую же процедуру 
```

- положить в кучу X (time O(log(n)))
```
помним, что у нас есть динамический массив, где мы храним все элменты кучи.
когда мы добавляем элемент - мы должны за константу добавить новый элемент X в конец массива и запустить просеивание элемента вверх
```

- достать самый большой | маленький элемент (time O(1))
```
помним, что у нас есть динамический массив, где мы храним все элменты кучи.
когда мы хотим самый большой или маленький элемент - мы знаем что этот элемент лежит в "корне" (под индексом 0 в куче) - и мы его возвращаем.
```

- удалить самый большой | маленький элемент (time O(log(n)))
```
помним, что у нас есть динамический массив, где мы храним все элменты кучи.
когда мы хотим удалить самый большой или маленький элемент:
1. мы меняем первый и последний элементы в динамическом массиве
2. запускаем shiftDown на первый элемент
```

- heapify (time O(n))
```
это процедура, которая позволяет из массива сделать куча на максимум или на минимум
рабоатет как: просеить все элементы вниз
```

**формулы для поиска девого и правого ребенка на массвие**
```text
leftChild = i*2 + 1
rightChild = i*2 + 2
parent = (i-1) // 2
```

## Min Heap
### Recursive
```python

```

### Iterative
```python
```