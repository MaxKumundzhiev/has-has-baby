**https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/**

## правильное решени
```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        maxLength, currentLength = 0, 1
        currentPosition = 1

        """
        maxLength       3
        currentLength   5
        currentPosition 7
        len             7
        1 2 3 0 6 7 8 9
                        |
        """
        while currentPosition <= len(nums)-1:
            if nums[currentPosition] > nums[currentPosition-1]:
                currentLength += 1
            else:
                maxLength = max(maxLength, currentLength)
                currentLength = 1
            currentPosition += 1
        return max(maxLength, currentLength)
```

## оценку по времени и памяти
- Time: O(n)
- Space: O(1)

## путь по которому вы пришли к решению
Сначала у меня возникла идея использовать скользящее окно с двумя поинтерами, медленным и быстрым. И я даже начал идти по примеру с этим алгоритмом, а потом понял, что у меня нет информации об предполседнем элементе и по идее можно было как то заменеджить это все же через скользящее окно, но интуитивно было понимание, что как то сложно реализуется. 

После, я подумал, а зачем окно, когда можно идти окном длиною в 2 и сравнимавать два элменета. Пока условию соблюдается, мы увеличиваем длину окошка, когда условие не соблюдается, мы перерасчитываем максимальную длину. 

## идея
начиная с первого элемента, итерироваться и на каждом шаге сравнивать элемент и его предыдущий, если соблюдается условие, мы увеличиваем длину нашего окна на 1. Как только услвоие не выполнилось, мы перерасчитываем макисмальную длину (сравнив ныннешнюю длину и предыдущую макимальную), также переопределяем нынешнюю длину сделав ее снова 1 (начинаем строить возрастающее окно заново).

