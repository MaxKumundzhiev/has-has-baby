## Деревья
- Деревья это структура данных, которая состоит из узлов (nodes). Каждый узел будет иметь одну или несколько ссылок на их детские ноды.
```python
class TreeNode:
    def __init__(self, val, left, right):
        self.val = val
        self.left = left
        self.right = right
```

## Деревья Поиска (BST - Binary Search Tree)
Деревья Поиска - это структура данных, которая состоит из узлов (nodes). Каждый узел будет иметь 1 или 2 ссылки на детские ноды. Главное свойство BST, для каждой вершины:
- слева меньше
- справа больше
- вершина удовлетворяет условию: `low < node.val < high`
```
example:
        10
       /  \
      5   11
     / \    \
   -2   7   15

property
    left:   subtree: -2 < 5  | 5 < 7 < 10 | 5 < 10
    right:  subtree: 15 > 11 | 11 > 10 
```

### Важные свойства Бинарного Дерева Поиска (BST)
- `центрированный обход` (inorder traverse) и `left -> node -> right` - дает `отсортированный по возрастанию порядок` элементов.
- `центрированный обход` (inorder traverse) и `right -> node -> left` - дает `отсортированный по убыванию порядок` элементов.
- `самое минимально значение хранится в самой левой ноде дерева`
```python
current = root
while current:
    current = current.left
```
- `самое максимальное значение хранится в самой правой ноде дерева`
```python
current = root
while current:
    current = current.right
```
- `сбалансированное дерево` - когда для каждого поддерева верно утверждение, что высота левого и правого поддерева отличается не более чем 1 `(asb(leftTreeHeight - rightTreeHeight)) ≤ 1`
- когда формируем бинарное дерево из массива, нужно помнить как находить индексы:
```python
- первый элемент массива - корень
- левый ребенок имеет индекс: i * 2 + 1, где i - индекс вершины в массиве root
- правой ребенок имеет индекс: i * 2 + 2, где i - индекс вершины в массиве root
- если значение null или *индекс вершины выходит за границы массива*, то вершина отсутствует
```


## Способы обхода дерева
1. Обход в глубину (DFS)
    - preorder
    - inorder
    - postorder
2. Обход в ширину (BFS)
    - level order

**Заметка**
- Обход в глубину (DFS) 
    - реализуется итеративно и рекурсивно
    - когда реализуется итеративно - используется stack и порядок LIFO (добавляется в конец, спимается с конца)
- Обход в ширину (BFS)
    - реализуется итеративно
    - когда реализуется итеративно - используется queue и порядок FIFO (добавляется в конец, спимается с начала)


## Существуют алгоритмы балансировки деревьев
 - Red Black Trees
 - AVL Trees


## Референсы
- https://right-lupin-f79.notion.site/Python-955206472c7e46f3982f6337ce1cc85d

